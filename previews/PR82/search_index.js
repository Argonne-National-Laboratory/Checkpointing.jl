var documenterSearchIndex = {"docs":
[{"location":"lib/checkpointing/#API","page":"API","title":"API","text":"","category":"section"},{"location":"lib/checkpointing/#Decorator-macros-for-loops","page":"API","title":"Decorator macros for loops","text":"","category":"section"},{"location":"lib/checkpointing/#Supported-Schemes","page":"API","title":"Supported Schemes","text":"","category":"section"},{"location":"lib/checkpointing/#Supported-Storages","page":"API","title":"Supported Storages","text":"","category":"section"},{"location":"lib/checkpointing/#Developer-variables-for-implementing-new-schemes","page":"API","title":"Developer variables for implementing new schemes","text":"","category":"section"},{"location":"lib/checkpointing/#Checkpointing.@ad_checkpoint","page":"API","title":"Checkpointing.@ad_checkpoint","text":"@ad_checkpoint(\n    alg,\n    loop,\n)\n\nThis macro is supposed to be only used in conjunction with EnzymeRules. It does not initialize the shadowcopy. Apply the checkpointing scheme alg on the loop loop expression.\n\n\n\n\n\n","category":"macro"},{"location":"lib/checkpointing/#Checkpointing.Revolve","page":"API","title":"Checkpointing.Revolve","text":"Revolve{MT}(\n    checkpoints::Int;\n    storage::AbstractStorage = ArrayStorage{MT}(checkpoints),\n    verbose::Int = 0,\n    gc::Bool = true,\n    write_checkpoints::Bool = false,\n    write_checkpoints_period::Int = 1,\n    write_checkpoints_filename::String = \"chkp\",\n) where {MT}\n\nCreates a new Revolve object for checkpointing.\n\ncheckpoints: is the number of checkpoints used for storage.\nstorage: is the storage backend to use (default is ArrayStorage).\nverbose::Int: Verbosity level for logging and diagnostics.\ngc::Bool: Whether to enable garbage collection (default is true).\nwrite_checkpoints::Bool: Whether to enable writing checkpoints (default is false).\nwrite_checkpoints_period::Int: The period for writing checkpoints (default is 1).\nwrite_checkpoints_filename::String: The filename for writing checkpoints (default is \"chkp\").\n\nReferences\n\nGriewank, A. & Walther, A. “Algorithm 799: Revolve: An Implementation of\n\nCheckpointing for the Reverse or Adjoint Mode of Computational Differentiation.” ACM Transactions on Mathematical Software.\n\nThis documentation outlines the structure, usage, and functionality of Revolve and should help users integrate the checkpointing scheme into their Julia projects.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Periodic","page":"API","title":"Checkpointing.Periodic","text":"Periodic(\n    checkpoints::Int;\n    storage::AbstractStorage = ArrayStorage{MT}(checkpoints),\n    verbose::Int = 0,\n    gc::Bool = true,\n    write_checkpoints::Bool = false,\n) where {MT}\n\nThe periodic scheme is used to store the state of the system at regular intervals and then restore it when needed.\n\ncheckpoints: is the number of checkpoints used for storage.\nstorage: is the storage backend to use (default is ArrayStorage).\nverbose::Int: Verbosity level for logging and diagnostics.\ngc::Bool: Whether to enable garbage collection (default is true).\nwrite_checkpoints::Bool: Whether to enable writing checkpoints (default is false).\n\nThe period will be div(steps, checkpoints).\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Online_r2","page":"API","title":"Checkpointing.Online_r2","text":"Online_r2{FT}(\n    checkpoints::Int,\n    storage::AbstractStorage = ArrayStorage{FT}(checkpoints);\n    verbose::Int = 0,\n) where {FT}\n\nThis implements the online checkpointing scheme for r=2 as described in the paper \"New Algorithms for Optimal Online Checkpointing\" by Philipp Stumm and Andrea Walther.\n\nThe key advantage is that the number of iterations does not have to be known a priori.\n\nCreates a new Online_r2 object for checkpointing.\n\ncheckpoints: is the number of checkpoints used for storage.\nstorage: is the storage backend to use (default is ArrayStorage).\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.ArrayStorage","page":"API","title":"Checkpointing.ArrayStorage","text":"ArrayStorage\n\nArray (RAM) storage for checkpointing.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.HDF5Storage","page":"API","title":"Checkpointing.HDF5Storage","text":"HDF5Storage\n\nA storage type for checkpointing that uses HDF5 files to store the checkpoints.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Scheme","page":"API","title":"Checkpointing.Scheme","text":"Scheme\n\nAbstract type from which all checkpointing schemes are derived.\n\n\n\n\n\n","category":"type"},{"location":"storage/#Storage","page":"Storage","title":"Storage","text":"The checkpoint storage types are derived from AbstractStorage\n\nusing Checkpointing\nstruct MyStorage{MT} <: AbstractStorage where {MT} end\n\nand have to implement the following functions.\n\nA constructor invoked by the user\n\nfunction MyStorage{MT}(n::Int) where {MT} end\n\nsave and load functions for the storage type\n\nBase.load(body::MT, storage::MyStorage{MT}, i::Int) where {MT}\nBase.save!(body::MT, storage::MyStorage{MT}, value, i::Int) where {MT}\n\nSize and dimension functions\n\nBase.size(storage::MyStorage{MT}) where {MT}\nBase.ndims(storage::MyStorage{MT}) where {MT}","category":"section"},{"location":"quickstart/#Explicit-1D-heat-equation","page":"Quick Start","title":"Explicit 1D heat equation","text":"# Explicit 1D heat equation\nusing Plots\nusing Checkpointing\nusing Enzyme\n\nmutable struct Heat\n    Tnext::Vector{Float64}\n    Tlast::Vector{Float64}\n    n::Int\n    λ::Float64\n    tsteps::Int\nend\n\nfunction advance(heat)\n    next = heat.Tnext\n    last = heat.Tlast\n    λ = heat.λ\n    n = heat.n\n    for i in 2:(n-1)\n        next[i] = last[i] + λ*(last[i-1]-2*last[i]+last[i+1])\n    end\n    return nothing\nend\n\n\nfunction sumheat(heat::Heat, chkpscheme::Scheme, tsteps::Int64)\n    @ad_checkpoint chkpscheme for i in 1:tsteps\n        heat.Tlast .= heat.Tnext\n        advance(heat)\n    end\n    return reduce(+, heat.Tnext)\nend\n\nfunction heat(scheme::Scheme, tsteps::Int)\n    n = 100\n    Δx=0.1\n    Δt=0.001\n    # Select μ such that λ ≤ 0.5 for stability with μ = (λ*Δt)/Δx^2\n    λ = 0.5\n\n    # Create object from struct. tsteps is not needed for a for-loop\n    heat = Heat(zeros(n), zeros(n), n, λ, tsteps)\n    # Shadow copy for Enzyme\n    dheat = Heat(zeros(n), zeros(n), n, λ, tsteps)\n\n    # Boundary conditions\n    heat.Tnext[1]   = 20.0\n    heat.Tnext[end] = 0\n\n    # Compute gradient\n    autodiff(Enzyme.ReverseWithPrimal, sumheat, Duplicated(heat, dheat), Const(scheme), Const(tsteps))\n\n    return heat.Tnext, dheat.Tnext[2:(end-1)]\nend\n\nPlot function values:\n\ntsteps = 500\nT, dT = heat(Revolve(4), tsteps)\n\nPlot gradient with respect to sum(T):\n\nplot(dT)","category":"section"},{"location":"schemes/#Checkpointing-Schemes","page":"Schemes","title":"Checkpointing Schemes","text":"A checkpointing scheme may support either for or while loops or both. Each scheme has to define a struct with a constructor derived from the abstract type Scheme.\n\nmutable struct MyScheme{MT} <: Scheme where {MT}\nfunction MyScheme{MT}(...) where {MT}\n\nThe constructor may take any number of arguments, but the first argument has to be the model type. The model type is the type of the model that is being differentiated.\n\nA scheme has then to implement the reverse pass with the checkpointing scheme that will replace the for or while loop\n\nfunction rev_checkpoint_for(\n    body::Function,\n    alg::Scheme,\n    model_input::MT,\n    shadowmodel::MT,\n    range\n) where {MT} end\nfunction rev_checkpoint_while(\n    body::Function,\n    alg::Scheme,\n    model_input::MT,\n    shadowmodel::MT,\n    condition::Function\n) where {MT}\n\nThe reverse pass for the checkpointing scheme will be called with the loop body body, the scheme alg, the model input model_input, the initialized shadow model shadowmodel, and the loop range range or the loop condition condition.","category":"section"},{"location":"#Checkpointing","page":"Home","title":"Checkpointing","text":"Checkpointing.jl provides checkpointing schemes for adjoint computations using automatic differentiation (AD) of time-stepping loops. Currently, we support the macro @ad_checkpoint, which differentiates and checkpoints a struct used in a while or for the loop with a UnitRange.\n\nEach loop iteration is differentiated using Enzyme.jl. We rely on ChainRulesCore.jl to integrate with AD tools applied to the code outside of the loop.\n\nThe schemes are agnostic to the AD tool being used and can be easily interfaced with any Julia AD tool. Currently, the package supports:","category":"section"},{"location":"#Scheme","page":"Home","title":"Scheme","text":"Revolve/Binomial checkpointing [1]\nPeriodic checkpointing\nOnline r=2 checkpointing for a while loops with a priori unknown number of iterations [2]","category":"section"},{"location":"#Rules","page":"Home","title":"Rules","text":"EnzymeRules.jl","category":"section"},{"location":"#Storage","page":"Home","title":"Storage","text":"ArrayStorage: Stores all checkpoints values in an array of type Array\nHDF5Storage: Stores all checkpoints values in an HDF5 file","category":"section"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"Currently, the package only supports UnitRange ranges in for loops. We will add range types on a per-need basis. Please, open an issue if you need support for a specific range type.\nWe only support Enzyme as the differentiation tool of the loop body. This is due to our strict requirement for a mutation-enabled AD tool in our projects. However, there is no fundamental reason why we could not support other AD tools. Please, open an issue if you need support for a specific AD tool.\nWe don't support any activity analysis. This implies that loop iterators have to be part of the checkpointed struct if they are used in the loop body. Currently, we store the entire struct at each checkpoint. This is not necessary, and we will add support for storing only the required fields in the future.","category":"section"},{"location":"#Future","page":"Home","title":"Future","text":"The following features are planned for development:\n\nSupport checkpoints on GPUs","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"section"},{"location":"#API","page":"Home","title":"API","text":"Pages = [\n    \"lib/checkpointing.md\",\n]\nDepth = 1","category":"section"},{"location":"#References","page":"Home","title":"References","text":"[1] Andreas Griewank and Andrea Walther. 2000. Algorithm 799: revolve: an implementation of checkpointing for the reverse or adjoint mode of computational differentiation. ACM Trans. Math. Softw. 26, 1 (March 2000), 19–45. DOI:https://doi.org/10.1145/347837.347846","category":"section"},{"location":"rules/#Rules","page":"Rules","title":"Rules","text":"Currently, EnzymeRules rule are provided for checkpointing. Adding a new rule system support for checkpointing requires calling the augmented forward run for the while and for loops. and the reverse call, respectively.","category":"section"}]
}
