var documenterSearchIndex = {"docs":
[{"location":"lib/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"CurrentModule = Checkpointing","category":"page"},{"location":"lib/checkpointing/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"lib/checkpointing/#Decorator-macros-for-loops","page":"Checkpointing","title":"Decorator macros for loops","text":"","category":"section"},{"location":"lib/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"@checkpoint_struct\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.@checkpoint_struct","page":"Checkpointing","title":"Checkpointing.@checkpoint_struct","text":"@checkpoint_struct(\n    alg,\n    model,\n    loop,\n)\n\nThis macro is supposed to be only used in conjunction with ChainRules. It does not initialize the shadowcopy. Apply the checkpointing scheme alg on the loop loop expression. model is the primal struct. shadowmodel contains the adjoints and is created here.  It is supposed to be initialized by ChainRules.\n\n\n\n\n\n@checkpoint_struct(\n    alg,\n    model,\n    shadowmodel,\n    loop,\n)\n\nApply the checkpointing scheme alg on the loop loop expression. model is the primal struct and shadowmodel the adjoint struct where the adjoints are seeded and retrieved.\n\n\n\n\n\n","category":"macro"},{"location":"lib/checkpointing/#Function-API","page":"Checkpointing","title":"Function API","text":"","category":"section"},{"location":"lib/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"checkpoint_struct","category":"page"},{"location":"lib/checkpointing/#Checkpointing.checkpoint_struct","page":"Checkpointing","title":"Checkpointing.checkpoint_struct","text":"checkpoint_struct(\n    body::Function\n    alg::Scheme,\n    model::MT,\n    shadowmodel::MT,\n) where {MT}\n\nDefault method for the function checkpoint_struct if the function is not specialized for an unknown scheme Scheme. body is the loop body as generated by the macro @checkpoint_struct and MT is the checkpointed struct.\n\n\n\n\n\n","category":"function"},{"location":"lib/checkpointing/#Supported-Schemes","page":"Checkpointing","title":"Supported Schemes","text":"","category":"section"},{"location":"lib/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Revolve\nPeriodic\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.Revolve","page":"Checkpointing","title":"Checkpointing.Revolve","text":"Revolve\n\nThis is a Julia adaptation of the functionality of Revolve; see Alg. 799 published by Griewank et al. A minor extension is the  optional bundle parameter that allows to treat as many loop iterations in one tape/adjoint sweep. If bundle is 1, the default, then the behavior is that of Alg. 799.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Periodic","page":"Checkpointing","title":"Checkpointing.Periodic","text":"Periodic\n\nPeriodic checkpointing scheme.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Developer-variables-for-implementing-new-schemes","page":"Checkpointing","title":"Developer variables for implementing new schemes","text":"","category":"section"},{"location":"lib/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Scheme\nActionFlag\nAction\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.Scheme","page":"Checkpointing","title":"Checkpointing.Scheme","text":"Scheme\n\nAbstract type from which all checkpointing schemes are derived.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.ActionFlag","page":"Checkpointing","title":"Checkpointing.ActionFlag","text":"ActionFlag\n\nEach checkpointing algorithm currently uses the same ActionFlag type for setting the next action in the checkpointing scheme none: no action store: store a checkpoint now equivalent to TAKESHOT in Alg. 79 restore: restore a checkpoint now equivalent to RESTORE in Alg. 79 forward: execute iteration(s) forward equivalent to ADVANCE in Alg. 79 firstuturn: tape iteration(s); optionally leave to return later;  and (upon return) do the adjoint(s) equivalent to FIRSTTURN in Alg. 799 uturn: tape iteration(s) and do the adjoint(s) equivalent to YOUTURN in Alg. 79 done: we are done with adjoining the loop equivalent to the terminate enum value in Alg. 79\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Action","page":"Checkpointing","title":"Checkpointing.Action","text":"Action\n\nStores the state of the checkpointing scheme after an action is taken.     * actionflag is the next action     * iteration is number of iterations for move forward     * startiteration is the loop step to start from     * cpnum is the checkpoint index number\n\n\n\n\n\n","category":"type"},{"location":"quickstart/#Explicit-1D-heat-equation","page":"Quick Start","title":"Explicit 1D heat equation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Checkpointing\nusing Plots\nusing Zygote\n\nmutable struct Heat\n    Tnext::Vector{Float64}\n    Tlast::Vector{Float64}\n    n::Int\n    λ::Float64\n    tsteps::Int\nend\n\nfunction advance(heat)\n    next = heat.Tnext\n    last = heat.Tlast\n    λ = heat.λ\n    n = heat.n\n    for i in 2:(n-1)\n        next[i] = last[i] + λ*(last[i-1]-2*last[i]+last[i+1])\n    end\n    return nothing\nend\n\n\nfunction sumheat(heat::Heat, chkpt::Scheme)\n    @checkpoint_struct revolve heat for i in 1:tsteps\n        heat.Tlast .= heat.Tnext\n        advance(heat)\n    end\n    return reduce(+, heat.Tnext)\nend\n\nn = 100\nΔx=0.1\nΔt=0.001\n# Select μ such that λ ≤ 0.5 for stability with μ = (λ*Δt)/Δx^2\nλ = 0.5\n# time steps\ntsteps = 500\n\n# Create object from struct\nheat = Heat(zeros(n), zeros(n), n, λ, tsteps)\n\n# Boundary conditions\nheat.Tnext[1]   = 20.0\nheat.Tnext[end] = 0\n\n# Set up AD\n# Number of available snapshots\nsnaps = 4\nverbose = 0\nrevolve = Revolve{Heat}(tsteps, snaps; verbose=verbose)\n\n# Compute gradient\ng = Zygote.gradient(sumheat, heat, revolve)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Plot function values:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"plot(heat.Tnext)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Plot gradient with respect to sum(T):","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"plot(g[1].Tnext[2:end-1])","category":"page"},{"location":"#Checkpointing","page":"Home","title":"Checkpointing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Checkpointing.jl provides checkpointing schemes for adjoint computations using automatic differentiation (AD) of time stepping loops. Currently, we support the macro @checkpoint_struct, which differentiates and checkpoints a struct used in the loop. Each loop iteration is differentiated using Enzyme.jl. We rely on ChainRulesCore.jl to integrate with AD tools applied to the code outside of the loop.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The schemes are agnostic to the AD tool being used and can be easily interfaced with any Julia AD tool. Currently, the package provides the following checkpointing schemes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Revolve/Binomial checkpointing [1]\nPeriodic checkpointing","category":"page"},{"location":"#Future","page":"Home","title":"Future","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following features are planned for development:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Online checkpointing schemes for adaptive timestepping \nComposition of checkpointing schemes\nMulti-level checkpointing schemes","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/checkpointing.md\",\n]\nDepth = 1","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Andreas Griewank and Andrea Walther. 2000. Algorithm 799: revolve: an implementation of checkpointing for the reverse or adjoint mode of computational differentiation. ACM Trans. Math. Softw. 26, 1 (March 2000), 19–45. DOI:https://doi.org/10.1145/347837.347846","category":"page"}]
}
