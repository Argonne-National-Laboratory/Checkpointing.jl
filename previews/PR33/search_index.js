var documenterSearchIndex = {"docs":
[{"location":"lib/checkpointing/","page":"API","title":"API","text":"CurrentModule = Checkpointing","category":"page"},{"location":"lib/checkpointing/#API","page":"API","title":"API","text":"","category":"section"},{"location":"lib/checkpointing/#Decorator-macros-for-loops","page":"API","title":"Decorator macros for loops","text":"","category":"section"},{"location":"lib/checkpointing/","page":"API","title":"API","text":"@checkpoint_struct\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.@checkpoint_struct","page":"API","title":"Checkpointing.@checkpoint_struct","text":"@checkpoint_struct(\n    alg,\n    model,\n    loop,\n)\n\nThis macro is supposed to be only used in conjunction with ChainRules. It does not initialize the shadowcopy. Apply the checkpointing scheme alg on the loop loop expression. model is the primal struct. shadowmodel contains the adjoints and is created here.  It is supposed to be initialized by ChainRules.\n\n\n\n\n\n","category":"macro"},{"location":"lib/checkpointing/#Supported-Schemes","page":"API","title":"Supported Schemes","text":"","category":"section"},{"location":"lib/checkpointing/","page":"API","title":"API","text":"Revolve\nPeriodic\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.Revolve","page":"API","title":"Checkpointing.Revolve","text":"Revolve\n\nThis is a Julia adaptation of the functionality of Revolve; see Alg. 799 published by Griewank et al. A minor extension is the  optional bundle parameter that allows to treat as many loop iterations in one tape/adjoint sweep. If bundle is 1, the default, then the behavior is that of Alg. 799.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Periodic","page":"API","title":"Checkpointing.Periodic","text":"Periodic\n\nPeriodic checkpointing scheme.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Supported-Storages","page":"API","title":"Supported Storages","text":"","category":"section"},{"location":"lib/checkpointing/","page":"API","title":"API","text":"ArrayStorage\nHDF5Storage\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.ArrayStorage","page":"API","title":"Checkpointing.ArrayStorage","text":"ArrayStorage\n\nArray (RAM) storage for checkpointing.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.HDF5Storage","page":"API","title":"Checkpointing.HDF5Storage","text":"HDF5Storage\n\nA storage type for checkpointing that uses HDF5 files to store the checkpoints.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Developer-variables-for-implementing-new-schemes","page":"API","title":"Developer variables for implementing new schemes","text":"","category":"section"},{"location":"lib/checkpointing/","page":"API","title":"API","text":"Scheme\nActionFlag\nAction\n","category":"page"},{"location":"lib/checkpointing/#Checkpointing.Scheme","page":"API","title":"Checkpointing.Scheme","text":"Scheme\n\nAbstract type from which all checkpointing schemes are derived.\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.ActionFlag","page":"API","title":"Checkpointing.ActionFlag","text":"ActionFlag\n\nEach checkpointing algorithm currently uses the same ActionFlag type for setting the next action in the checkpointing scheme none: no action store: store a checkpoint now equivalent to TAKESHOT in Alg. 79 restore: restore a checkpoint now equivalent to RESTORE in Alg. 79 forward: execute iteration(s) forward equivalent to ADVANCE in Alg. 79 firstuturn: tape iteration(s); optionally leave to return later;  and (upon return) do the adjoint(s) equivalent to FIRSTTURN in Alg. 799 uturn: tape iteration(s) and do the adjoint(s) equivalent to YOUTURN in Alg. 79 done: we are done with adjoining the loop equivalent to the terminate enum value in Alg. 79\n\n\n\n\n\n","category":"type"},{"location":"lib/checkpointing/#Checkpointing.Action","page":"API","title":"Checkpointing.Action","text":"Action\n\nStores the state of the checkpointing scheme after an action is taken.     * actionflag is the next action     * iteration is number of iterations for move forward     * startiteration is the loop step to start from     * cpnum is the checkpoint index number\n\n\n\n\n\n","category":"type"},{"location":"storage/#Storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"The checkpoint storage types are derived from AbstractStorage ","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"using Checkpointing","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"using Checkpointing\nstruct MyStorage{MT} <: AbstractStorage where {MT} end","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"and have to implement the following functions.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"A constructor invoked by the user","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"function MyStorage{MT}(n::Int) where {MT} end","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Set and get functions for the storage type","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Base.getindex(storage::MyStorage{MT}, i::Int) where {MT}\nBase.setindex!(storage::MyStorage{MT}, value, i::Int) where {MT}","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Size and dimension functions","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Base.size(storage::MyStorage{MT}) where {MT}\nBase.ndims(storage::MyStorage{MT}) where {MT}","category":"page"},{"location":"quickstart/#Explicit-1D-heat-equation","page":"Quick Start","title":"Explicit 1D heat equation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Explicit 1D heat equation\nusing Plots\nusing Checkpointing\nusing Enzyme\n\nmutable struct Heat\n    Tnext::Vector{Float64}\n    Tlast::Vector{Float64}\n    n::Int\n    λ::Float64\n    tsteps::Int\nend\n\nfunction advance(heat)\n    next = heat.Tnext\n    last = heat.Tlast\n    λ = heat.λ\n    n = heat.n\n    for i in 2:(n-1)\n        next[i] = last[i] + λ*(last[i-1]-2*last[i]+last[i+1])\n    end\n    return nothing\nend\n\n\nfunction sumheat(heat::Heat, chkpscheme::Scheme, tsteps::Int64)\n    # AD: Create shadow copy for derivatives\n    @checkpoint_struct chkpscheme heat for i in 1:tsteps\n        heat.Tlast .= heat.Tnext\n        advance(heat)\n    end\n    return reduce(+, heat.Tnext)\nend\n\nfunction heat(scheme::Scheme, tsteps::Int)\n    n = 100\n    Δx=0.1\n    Δt=0.001\n    # Select μ such that λ ≤ 0.5 for stability with μ = (λ*Δt)/Δx^2\n    λ = 0.5\n\n    # Create object from struct. tsteps is not needed for a for-loop\n    heat = Heat(zeros(n), zeros(n), n, λ, tsteps)\n    # Shadow copy for Enzyme\n    dheat = Heat(zeros(n), zeros(n), n, λ, tsteps)\n\n    # Boundary conditions\n    heat.Tnext[1]   = 20.0\n    heat.Tnext[end] = 0\n\n    # Compute gradient\n    autodiff(Enzyme.ReverseWithPrimal, sumheat, Duplicated(heat, dheat), scheme, tsteps)\n\n    return heat.Tnext, dheat.Tnext[2:end-1]\nend","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Plot function values:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"tsteps = 500\nT, dT = heat(Revolve{Heat}(tsteps,4), tsteps)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Plot gradient with respect to sum(T):","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"plot(dT)","category":"page"},{"location":"schemes/#Checkpointing-Schemes","page":"Schemes","title":"Checkpointing Schemes","text":"","category":"section"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"A checkpointing scheme may support either for or while loops or both. Each scheme has to define a struct with a constructor derived from the abstract type Scheme.","category":"page"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"mutable struct MyScheme{MT} <: Scheme where {MT}\nfunction MyScheme{MT}(...) where {MT}","category":"page"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"The constructor may take any number of arguments, but the first argument has to be the model type. The model type is the type of the model that is being differentiated. ","category":"page"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"A scheme has then to implement the reverse pass with the checkpointing scheme that will replace the for or while loop","category":"page"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"function rev_checkpoint_struct_for(\n    body::Function,\n    alg::Scheme,\n    model_input::MT,\n    shadowmodel::MT,\n    range\n) where {MT} end\nfunction rev_checkpoint_struct_while(\n    body::Function,\n    alg::Scheme,\n    model_input::MT,\n    shadowmodel::MT,\n    condition::Function\n) where {MT}","category":"page"},{"location":"schemes/","page":"Schemes","title":"Schemes","text":"The reverse pass for the checkpointing scheme will be called with the loop body body, the scheme alg, the model input model_input, the initialized shadow model shadowmodel, and the loop range range or the loop condition condition.","category":"page"},{"location":"#Checkpointing","page":"Home","title":"Checkpointing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Checkpointing.jl provides checkpointing schemes for adjoint computations using automatic differentiation (AD) of time-stepping loops. Currently, we support the macro @checkpoint_struct, which differentiates and checkpoints a struct used in a while or for the loop with a UnitRange.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each loop iteration is differentiated using Enzyme.jl. We rely on ChainRulesCore.jl to integrate with AD tools applied to the code outside of the loop.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The schemes are agnostic to the AD tool being used and can be easily interfaced with any Julia AD tool. Currently, the package supports:","category":"page"},{"location":"#Scheme","page":"Home","title":"Scheme","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Revolve/Binomial checkpointing [1]\nPeriodic checkpointing\nOnline r=2 checkpointing for a while loops with a priori unknown number of iterations [2]","category":"page"},{"location":"#Rules","page":"Home","title":"Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChainRulesCore.jl\nEnzymeRules.jl","category":"page"},{"location":"#Storage","page":"Home","title":"Storage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArrayStorage: Stores all checkpoints values in an array of type Array\nHDF5Storage: Stores all checkpoints values in an HDF5 file","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the package only supports UnitRange ranges in for loops. We will add range types on a per-need basis. Please, open an issue if you need support for a specific range type.\nWe only support Enzyme as the differentiation tool of the loop body. This is due to our strict requirement for a mutation-enabled AD tool in our projects. However, there is no fundamental reason why we could not support other AD tools. Please, open an issue if you need support for a specific AD tool.\nWe don't support any activity analysis. This implies that loop iterators have to be part of the checkpointed struct if they are used in the loop body. Currently, we store the entire struct at each checkpoint. This is not necessary, and we will add support for storing only the required fields in the future.","category":"page"},{"location":"#Future","page":"Home","title":"Future","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following features are planned for development:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Support checkpoints on GPUs","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/checkpointing.md\",\n]\nDepth = 1","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Andreas Griewank and Andrea Walther. 2000. Algorithm 799: revolve: an implementation of checkpointing for the reverse or adjoint mode of computational differentiation. ACM Trans. Math. Softw. 26, 1 (March 2000), 19–45. DOI:https://doi.org/10.1145/347837.347846","category":"page"},{"location":"rules/#Rules","page":"Rules","title":"Rules","text":"","category":"section"},{"location":"rules/","page":"Rules","title":"Rules","text":"Currently, EnzymeRules and ChainRulesCore rules are provided for checkpointing. Adding a new rule system support for checkpointing requires calling the augmented forward run for the while and for loops","category":"page"},{"location":"rules/","page":"Rules","title":"Rules","text":"function fwd_checkpoint_struct_for(body::Function, scheme::Scheme, model, range::UnitRange{Int64}) end\nfunction fwd_checkpoint_struct_while(body::Function, scheme::Scheme, model, condition::Function) end","category":"page"},{"location":"rules/","page":"Rules","title":"Rules","text":"and the reverse call, respectively.","category":"page"},{"location":"rules/","page":"Rules","title":"Rules","text":"function rev_checkpoint_struct_for(\n    body::Function,\n    alg::Scheme,\n    model_input::MT,\n    shadowmodel::MT,\n    range::UnitRange\n) where {MT} end\nfunction rev_checkpoint_struct_while(\n    body::Function,\n    alg::Online_r2,\n    model_input::MT,\n    shadowmodel::MT,\n    condition::Function\n) where {MT} end","category":"page"}]
}
